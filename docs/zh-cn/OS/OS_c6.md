

# OS 第六章

>   操作系统的虚拟内存管理技术中的页面置换算法

## 功能与目标

功能 : 当缺页中断发生, 需要调入新的页面而内存已满时, 选择内存当中哪个物理页面被置换.

目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数)

- 具体来说, 把未来不再使用的或短期内较少使用的页面换出
  - 通常只能在局部性原理指导下依据过去的统计数据来进行预测.

页面锁定 : 

- 用于描述必须常驻内存的操作系统的关键部分或时间关键的应用进程
- 实现的方式是 : 在页表中添加锁定标记位(lock bit).

## 实验设置与评价方法

实例 :

记录一个进程对页访问的一个轨迹

-   举例 : 虚拟地址跟踪(页号, 偏移)...
    -   (3,0) (1,9) (4,1) (2,1) (5,3) (2,0) ...
-   生成的页面轨迹
    -   3, 1, 4, 2, 5, 2, 1, 2, 3, 4 ...（替换为c,a,d,b,e,b,a,b,c,d）

模拟一个页面置换的行为并且记录产生页缺失数的数量

-   更少的缺失, 更好的性能



**分类：**

1. 局部置换算法：
     置换页面的选择范围仅限于当前进程占用的物理页面内。
     具体又有一系列算法：

     - 最优算法
     - 先进先出算法
     - 最近最久未使用算法
     - 最近最久未使用算法又衍生出两种近似算法
       - 时钟算法
       - 最不常用算法

2. 全局置换算法；
     置换页面的选择范围是所有可换出的物理页面。
     具体有
     - 工作集算法
     - 缺页率算法





## 局部页面置换算法

### 最优页面置换算法

- 基本思路 : 
  - 当一个缺页中断发生时, 对于保存在内存当中的每一个逻辑页面
  - 计算在它的下一次访问之前, 还需等待多长时间
  - 从中选择等待时间最长的那个, 作为被置换的页面.

- 这是一种理想情况, 在实际系统中是无法实现的
  - 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.

- 可用作其他算法的性能评价的依据
  - 在一个模拟器上运行某个程序, 并记录每一次的页面访问情况, 在第二遍运行时即可使用最优算法

---

- 有五个页面a、b、c、d、e

- 前四个页面：abcd先加载

- 在需要置换e时，等待时间最长的那个, 作为被置换的页面
  - 是d
- 则d -> e

![image-20211214004042456](OS/image-20211214004042456.png)

---

### 先进先出算法（First-In First-Out, FIFO）

- 基本思路 : 选择在内存中驻留时间最长的页面淘汰.
  - 具体来说：系统维护着一个链表, 记录了所有位于内存当中的逻辑页面
  - 从链表的排列顺序来看, 链首页面的驻留时间最长, 链尾页面的驻留时间最短
  - 当发生一个缺页中断时, 把链首页面淘汰出去, 并把新的页面添加到链表的末尾.

- 性能较差, 调出的页面有可能是经常要访问的页面. 并且有 **Belady现象**. FIFO算法很少单独使用.



![image-20211214183708743](OS/image-20211214183708743.png)



### 最近最久未使用算法(Least Recently Used,LRU)

基本思路 : 当一个缺页中断发生时, 选择最久未使用的那个页面, 并淘汰.

它是对最优页面置换算法的一个近似, 其依据是程序的局部性原理

- 即在最近一小段时间(最近几条指令)内, 如果某些页面被频繁地访问, 那么再将来的一小段时间内, 他们还可能会再一次被频繁地访问. 
- 反过来说, 如果过去某些页面长时间未被访问, 那么在将来它们还可能会长时间地得不到访问.

LRU算法需要记录各个页面使用时间的先后顺序, 开销比较大.

![image-20211214201702976](OS/image-20211214201702976.png)

两种可能的实现方法是 :

-   系统维护一个页面链表
    -   最近刚刚使用过的页面作为首节点, 最久未使用的作为尾结点.
    -    再一次访问内存时, 找出相应的页面, 把它从链表中摘下来, 再移动到链表首. 
    -   每次缺页中断发生时, 淘汰链表末尾的页面.

-   设置一个活动页面栈
    -   当访问某页时, 将此页号压入栈顶
    -   然后, 考察栈内是否有与此页面相同的页号, 若有则抽出. 
    -   当需要淘汰一个页面时, 总是选择栈底的页面, 它就是最久未使用的

![image-20211214203542202](OS/image-20211214203542202.png)

### 时钟页面置换算法

基本思路 :

- 需要用到页表项的访问位
- 当一个页面被装入内存时, 把该位初始化为0
- 然后如果这个页面被访问, 则把该位置设为1;

- 把各个页面组织成环形链表(类似钟表面), 把指针指向最老的页面(最先进来);

- 当发生一个缺页中断时, 考察指针所指向的最老页面
  - 若它的访问位为0, 立即淘汰; 若访问位为0, 然后指针往下移动一格
  - 如此下去, 直到找到被淘汰的页面, 然后把指针移动到下一格.

流程 :

- 如果访问页在物理内存中, 访问位置1.

- 如果不在物理页, 从指针当前指向的物理页开始
  - 如果访问位0, 替换当前页, 指针指向下一个物理页; 
  - 如果访问位为1, 置零以后访问下一个物理页再进行判断. 
  - 如果所有物理页的访问位都被清零了, 又回到了第一次指针所指向的物理页进行替换.



![img](OS/Clock页面置换算法.png)

时钟置换算法实际还有一些改进。

例如：

- 减少修改页的缺页处理开销。
  - 因为被修改的页如果要被置换，需要先写到外存，再将需要的页写入内存，开销至少乘2
  - 为了减小修改过的页被置换，可以遇到被修改过的页指针就跳过。而在系统空闲时定期地将内存写入外存。实现通过在页面中增加修改位，并在访问时进行相应修改，缺页扫描时跳过有修改的页面。

![image-20211214204819188](OS/image-20211214204819188.png)



### 二次机会算法

因为考虑到时钟页面置换算法, 有时候会把一些 dirty bit 为1(有过写操作)的页面进行置换, 这样的话, 代价会比较大. 因此, 可以结合访问位和脏位一起来决定应该置换哪一页.

used   dirty     →  used   dirty

 0         0                  replace

 0         1                  0         0

 1          0                 0         0 

 1          1                 0         1 

相当于说, 替换的优先级, 没有读写也没写过, 那么直接走, 如果写过或者访问过, 那么给你一次机会, 如果又写过, 又访问过, 那么久给你两次机会.

![image-20211214215933401](OS/image-20211214215933401.png)

![image-20211214220458390](OS/image-20211214220458390.png)





### 最不常用算法

Least Frequently used, LFU

基本思路 : 当一个缺页中断发生时, 选择访问次数最少的那个页面, 并淘汰.

实现方法 : 

- 对每一个页面设置一个访问计数器, 每当一个页面被访问时, 该页面的访问计数器加1. 
- 当发生缺页中断时, 淘汰计数值最小的那个页面.

LRU和LFU的对比 : 

- LRU考察的是多久未访问, 时间越短越好. 
- LFU考察的是访问的次数和频度, 访问次数越多越好.

> LFU与时钟算法都是对LRU算法的一种简化近似，开销减小，同时精度下降。LFU是比较难实现的，因此在内存管理中基本不会采用，但是在读硬盘文件的时候对时间要求不高的场景中还是可以使用的。



### Belady现象(科学家名字)

在采用FIFO算法时, 有时会出现分配的物理页面数增加, 缺页率反而提高的异常现象;

出现原因 : 

- FIFO算法的置换特征与进程访问内存的动态特征是矛盾的
- 与置换算法的目标是不一致的(即替换较少使用的页面),
- 因此, 被它置换出去的页面不一定是进程不会访问的.

#### FIFO

帧为3时：

![image-20211214221015221](OS/image-20211214221015221.png)

帧为4时：

![image-20211214221052498](OS/image-20211214221052498.png)



#### LRU

![image-20211214221202085](OS/image-20211214221202085.png)

> LRU为什么不会发生Belady异常
>
> 实页数增加 —> 能贮存的页数增加 —> 哪些页？—> 访问频率高的页
>
> LRU当中替换的是使用频率最低的页，留下的都是使用频率高的页。当实页数增加，能够留下的高频访问的页也就更多，这直接关系到命中率的增加。



### LRU / FIFO 和 Clock 的比较

- LRU和FIFO都是先进先出的思路
- LRU是针对页面最近访问时间来进行排序, 所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了)
- FIFO是针对页面进入内存的时间来进行排序, 这个时间是固定不变的, 所以各个页面之间的先后顺序是固定的
- 如果一个页面在进入内存后没有被访问, 那么它的最近访问时间就是它进入内存的时间
  - 换句话说, 如果内存当中的所有页面都未曾访问过, 那么LRU算法就退化为了FIFO算法.



## 全局页面置换算法

### 工作集模型

前面介绍的各种页面置换算法, 都是基于一个前提, 即**程序的局部性原理**.但是此原理是否成立?

-   如果局部性原理不成立, 那么各种页面置换算法就没有说明分别, 也没有什么意义. 例如 : 假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,6,7,8,9..., 即单调递增, 那么在物理页面数有限的前提下, 不管采用何种置换算法, 每次的页面访问都必然导致缺页中断.
-   如果局部性原理是成立的, 那么如何来证明它的存在, 如何来对它进行定量地分析? 这就是工作集模型.



### 工作集

工作集 : 一个进程当前正在使用的逻辑页面集合，可以使用一个二元函数 W(t, delta) 来表示 :

- t 是当前的执行时刻;

- delta 称为工作集窗口, 即一个定长的页面访问的时间窗口;

- W(t, delta) = 在当前时刻 t 之前的 delta 时间  窗口当中的所有页面所组成的集合(随着 t 的变化, 该集合也在不断的变化)

- |W(t, delta)| 是工作集的大小, 即逻辑页的数量.

- 工作集大小的变化 : 进程开始执行后, 随着访问新页面逐步建立较稳定的工作集. 当内存访问的局部性区域的位置大致稳定时, 工作集大小也大致稳定; 局部性区域的位置改变时, 工作集快速扩张和收缩过渡到下一个稳定值.



### 常驻集

常驻集是指在当前时刻, 进程实际驻留在内存当中的页面集合.

-   工作集是进程在运行过程中固有的性质, 而常驻集取决于系统分配给进程的物理页面数目, 以及所采用的页面置换算法;
-   如果一个进程的整个工作集都在内存当中, 即常驻集 包含 工作集, 那么进程将很顺利地运行, 而不会造成太多的缺页中断(直到工作集发生剧烈变动, 从而过渡到另一个状态);
-   当进程常驻集的大小达到某个数目之后, 再给它分配更多的物理页面, 缺页率也不会明显下降.



### 工作集页置换算法

工作集置换算法的思路：换出不在工作集中的页面。



- 系统维护窗口内的访存页面链表；
- 访存时，换出不在工作集的页面，更新访存链表；
- 缺页时，换入页面，更新访存链表。
- 可以看到，缺页处理很简单，但是每次访存都要进行判断，开销还是很大的。这与LRU算法是类似的。
  

![image-20211219210728594](OS/image-20211219210728594.png)

> T4 中把a去除不是因为局部置换强制，而是因为前四次里根本没有用到
>
> T6 中把e加进来只是单纯用到
>
> T7中去掉d跟T4同理
>
> 窗口是固定



### 缺页率置换算法

可变分配策略 : 常驻集大小可变. 

例如 : 每个进程在刚开始运行的时候, 先根据程序大小给它分配一定数目的物理页面, 然后在进程运行过程中, 再动态地调整常驻集的大小.

-   可采用全局页面置换的方式, 当发生一个缺页中断时, 被置换的页面可以是在其他进程当中, 各个并发进程竞争地使用物理页面.
-   优缺点 : 性能较好, 但增加了系统开销.
-   具体实现 : 可以使用缺页率算法来动态调整常驻集的大小.

缺页率

- 表示 "缺页次数 / 内存访问次数"

- 影响因素 :
  - 页面置换算法 
  - 分配给进程的物理页面数目
  - 页面本身的大小
  - 程序的编写方法

![image-20211219211346445](OS/image-20211219211346445.png)

---

案例：

1. 五个红点是中断处，需要判断
2. 第一、三、五个红点满足条件二
   - 仅需要增加缺失页即可
3. 第二、四个红点满足条件一
   - 清掉间隔时间内没有引用的页
   - 增加需要增加的页

![image-20211219211700289](OS/image-20211219211700289.png)

### 抖动问题

-   如果分配给一个进程的物理页面太少, 不能包含整个的工作集, 即常驻集 属于 工作集, 那么进程将会造成很多的缺页中断, 需要频繁的在内存与外存之间替换页面, 从而使进程的运行速度变得很慢, 我们把这种状态称为 "抖动".
-   产生抖动的原因 : 随着驻留内存的进程数目增加, 分配给每个进程的物理页面数不断就减小, 缺页率不断上升. 所以OS要选择一个适当的进程数目和进程需要的帧数, 以便在并发水平和缺页率之间达到一个平衡.

![image-20211219213439580](OS/image-20211219213439580.png)
